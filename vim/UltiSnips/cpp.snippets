snippet ifndef "Expand ifdef" !b
#ifndef $1
#define $1
	$2
#endif
endsnippet

snippet testinit "Boost test init test module" b
///Flag to use BOOST_TEST dynamic library, not just the include library.
#define BOOST_TEST_DYN_LINK
/// Module subsitutes the main C++ function, only one module per project.
#define BOOST_TEST_MODULE $1_module
endsnippet

snippet testinclude "Boost test include: unit_test.hpp" b
#include <boost/test/unit_test.hpp>
endsnippet

snippet testsuite "Boost test suite" b
BOOST_AUTO_TEST_SUITE($1)
	$2
BOOST_AUTO_TEST_SUITE_END()
endsnippet

snippet testcase "Boost test case" b
BOOST_AUTO_TEST_CASE($1)
{
	$2
}
endsnippet

snippet bc "BOOST_CHECK" b
BOOST_CHECK(${1:comparisson});
endsnippet
snippet bcm "BOOST_CHECK_MESSAGE" b
BOOST_CHECK_MESSAGE(${1:comparisson},
	"${2:message}");
endsnippet
snippet bw "BOOST_WARN" b
BOOST_WARN(${1:comparisson});
endsnippet
snippet br "BOOST_REQUIRE" b
BOOST_REQUIRE(${1:comparisson});
endsnippet
snippet bceq "BOOST_CHECK_EQUAL" b
BOOST_CHECK_EQUAL($1,$2);
endsnippet
snippet bcgt "BOOST_CHECK_GT" b
BOOST_CHECK_GT($1,$2);
endsnippet
snippet bclt "BOOST_CHECK_LT" b
BOOST_CHECK_LT($1,$2);
endsnippet

snippet vtk6 "VTK6 compatibility defines" b
#define vtkRenderingCore_AUTOINIT 4(vtkInteractionStyle,vtkRenderingFreeType, \
vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)
#define vtkRenderingVolume_AUTOINIT 1(vtkRenderingVolumeOpenGL)
endsnippet

snippet setget "set and get function in .h" b
void Set${1:CamelName}(${2:type} ${1/(^[A-Z])|([A-Z]+)/(?1:\l$0)(?2:_\l$0)/g}){ ${1/(^[A-Z])|([A-Z]+)/(?1:\l$0)(?2:_\l$0)/g}_ = ${1/(^[A-Z])|([A-Z]+)/(?1:\l$0)(?2:_\l$0)/g};};
$2 Get$1(){ return ${1/(^[A-Z])|([A-Z]+)/(?1:\l$0)(?2:_\l$0)/g}_;};
endsnippet


# Casts
snippet cast "Static Cast" w
static_cast<${1}>(${2})${0}
endsnippet
snippet cast "Reinterpret Cast" w
reinterpret_cast<${1}>(${2})${0}
endsnippet
snippet cast "Dynamic Cast" w
dynamic_cast<${1}>(${2})${0}
endsnippet
snippet cast "Const Cast" w
const_cast<${1}>(${2})${0}
endsnippet

# Google Mock
snippet ass "ASSERT_THAT" b
ASSERT_THAT($1,$2);
endsnippet

snippet TEST_F "TEST_F" b
TEST_F(${1:FixtureClass}, ${2:TestName}) {
	$3
}
endsnippet
#boost: program_options

snippet poclass "program_option full class .cpp" bm
#include <iostream>
#include <string>
#include <fstream>
using namespace std;
${1:poinit}
${2:pofunction}
endsnippet

snippet pocall "call to program options from main()" b
auto vm = program_options(argc, argv);
endsnippet

snippet pofunction "program_option parse function" bm
po::variables_map program_options(const int &argc, char** const & argv)
{
	${1:pobasic}
	${2:poOpenConfig}
    return vm;
}
endsnippet

snippet poinit "po include and namespace" b
#include <boost/program_options.hpp>
namespace po = boost::program_options;
endsnippet

snippet pobasic "po only command line setup" bm
// Declare a group of options that will be
// allowed only on command line
po::options_description generic("Generic options");
generic.add_options()
	("version,v", "print version string")
	("help,h", "produce help message")
	("config,c", po::value<string>()->default_value("config_file.init"),
		  "name of a file of a configuration.")
	;

// Declare a group of options that will be
// allowed both on command line and in
// config file
po::options_description config("Configuration");
config.add_options()
	("${1:cmdlinename}", po::value<int>()->default_value(${2}),
		  "$1 description")
	;

// Hidden options, will be allowed both on command line and
// in config file, but will not be shown to the user.
po::options_description hidden("Hidden options");
hidden.add_options()
	("input-file", po::value< vector<string> >(), "input file")
	;

po::options_description cmdline_options;
cmdline_options.add(generic).add(config).add(hidden);

po::options_description config_file_options;
config_file_options.add(config).add(hidden);

po::options_description visible("Allowed options");
visible.add(generic).add(config);

po::positional_options_description p;
p.add("input-file", -1);

po::variables_map vm;
store(po::command_line_parser(argc, argv).
	  options(cmdline_options).positional(p).run(), vm);
notify(vm);
if (vm.count("help")) {
	cout << visible << "\n";
	return 0;
}

endsnippet

snippet poOpenConfig "open config file" bm
string config_file = vm["config"].as<string>();
ifstream ifs(config_file.c_str());
if (!ifs)
{
	throw(runtime_error("Can not open config file: " + config_file + " ,use -c option"));
}
else
{
	store(parse_config_file(ifs, config_file_options), vm);
	notify(vm);
}
endsnippet
