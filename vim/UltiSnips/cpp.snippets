snippet licp "license with my name (property)" b
/* Copyright (C) 2021 Pablo Hernandez-Cerdan */

endsnippet

snippet licsgext "license for sgext (gpl3)" b
/* ********************************************************************
 * Copyright (C) 2021 Pablo Hernandez-Cerdan.
 *
 * This file is part of SGEXT: http://github.com/phcerdan/sgext.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * *******************************************************************/

endsnippet

snippet licgpl "License: GPL3" b
/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

endsnippet

snippet ifnotndebug "If not defined NDEBUG"
#if !defined(NDEBUG)
#endif
endsnippet
snippet licmit "License: MIT " b
/* Copyright (c) 2021 Pablo Hernandez-Cerdan
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE. */

endsnippet

snippet licmpl "License: MPL 2.0 Mozilla Public License " b
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

endsnippet

snippet lichisto "license with my name and reference to LICENSE" b
/* Copyright (C) 2021 Pablo Hernandez-Cerdan
 * See LICENSE on https://github.com/phcerdan/histo-header */

endsnippet
snippet licitk "ITK license" b
/*=========================================================================
 *
 *  Copyright NumFOCUS
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0.txt
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *=========================================================================*/

endsnippet

snippet licdgtal "license dgtal" b
/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

endsnippet

snippet enumc "enum class" b
enum class $1 {
    /** */
    $2
};
endsnippet
snippet switch_case "switch case" b
switch($1) {
    case $2: break;
    default:
}
endsnippet

snippet nameSG "namespace SG" b
namespace SG {$1
} // end namespace SG
endsnippet

snippet nameWM "namespace WM" b
namespace WM {$1
} // end namespace WM
endsnippet

global !p
import vim
def commentLine(ll = 79):
	try:
	    xrange
	except:
	    xrange=range
	r="/"
	for a in xrange(ll - 2):
		r+="*"
	r+="/"
	return r

endglobal
snippet "(\/\/(\s)?)?sep" "---- ----//" rb
`!p snip.rv = commentLine()`
endsnippet
snippet com "Comment /** */" b
/** ${1:Comment} */
endsnippet
snippet comlin "Comment line" !b
/************ ${1:TEXT} *************/
endsnippet
snippet comsep "Comment Separator, with fixed length" !b
`!p snip.rv = commentLine()`
/* ${1:TEXT} */
`!p snip.rv = commentLine()`
$0
endsnippet
snippet ifndef "Expand ifndef" !b
#ifndef $1
#define $1
	$2
#endif
endsnippet

snippet ifdef "Expand ifdef" !b
#ifdef ${1:VISUALIZE}
	$2
#endif
endsnippet

snippet testinit "Boost test init test module" b
///Flag to use BOOST_TEST dynamic library, not just the include library.
#define BOOST_TEST_DYN_LINK
/// Module subsitutes the main C++ function, only one module per project.
#define BOOST_TEST_MODULE $1_module
endsnippet

snippet testinclude "Boost test include: unit_test.hpp" b
#include <boost/test/unit_test.hpp>
endsnippet

snippet testsuite "Boost test suite" b
BOOST_AUTO_TEST_SUITE($1)
	$2
BOOST_AUTO_TEST_SUITE_END()
endsnippet

snippet testcase "Boost test case" b
BOOST_AUTO_TEST_CASE($1)
{
	$2
}
endsnippet

snippet bc "BOOST_CHECK" b
BOOST_CHECK(${1:comparisson});
endsnippet
snippet bcm "BOOST_CHECK_MESSAGE" b
BOOST_CHECK_MESSAGE(${1:comparisson},
	"${2:message}");
endsnippet
snippet bw "BOOST_WARN" b
BOOST_WARN(${1:comparisson});
endsnippet
snippet br "BOOST_REQUIRE" b
BOOST_REQUIRE(${1:comparisson});
endsnippet
snippet bceq "BOOST_CHECK_EQUAL" b
BOOST_CHECK_EQUAL($1,$2);
endsnippet
snippet bcgt "BOOST_CHECK_GT" b
BOOST_CHECK_GT($1,$2);
endsnippet
snippet bclt "BOOST_CHECK_LT" b
BOOST_CHECK_LT($1,$2);
endsnippet

snippet defvtk6 "VTK6 compatibility defines" b
#define vtkRenderingCore_AUTOINIT 4(vtkInteractionStyle,vtkRenderingFreeType, \
vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)
#define vtkRenderingVolume_AUTOINIT 1(vtkRenderingVolumeOpenGL)
endsnippet

snippet setget "set and get function in .h" b
void Set${1:CamelName}(${2:type} ${1/(^[A-Z])|([A-Z]+)/(?1:\l$0)(?2:_\l$0)/g}){ ${1/(^[A-Z])|([A-Z]+)/(?1:\l$0)(?2:_\l$0)/g}_ = ${1/(^[A-Z])|([A-Z]+)/(?1:\l$0)(?2:_\l$0)/g};};
$2 Get$1(){ return ${1/(^[A-Z])|([A-Z]+)/(?1:\l$0)(?2:_\l$0)/g}_;};
endsnippet


# Casts
snippet cast "Static Cast" w
static_cast<${1}>(${2})${0}
endsnippet
snippet cast "Reinterpret Cast" w
reinterpret_cast<${1}>(${2})${0}
endsnippet
snippet cast "Dynamic Cast" w
dynamic_cast<${1}>(${2})${0}
endsnippet
snippet cast "Const Cast" w
const_cast<${1}>(${2})${0}
endsnippet

# Google Mock
snippet ass "ASSERT_THAT Google Mock" b
ASSERT_THAT($1,$2);
endsnippet

snippet testfixture "Class fixture Google Mock" !b
struct ${1:FixtureClass} : public ::testing::Test {
    void SetUp() override {
    }
};
endsnippet
snippet TEST_F "TEST_F Google Mock" !b
TEST_F(${1:FixtureClass}, ${2:TestName}) {
	$3
}
endsnippet
snippet TESTG "TEST Google Mock" !b
TEST(${1:TestClass}, ${2:TestName}) {
	$3
}
endsnippet
#boost: program_options
snippet vflag "VFLAG conditional to visualize tests" b
if (VFLAG) viewer.Visualize();
endsnippet

snippet poclass "program_option full class .cpp" bm
#include <iostream>
#include <string>
#include <fstream>
using namespace std;
${1:poinit}
${2:pofunction}
endsnippet

snippet pocall "call to program options from main()" b
auto vm = program_options(argc, argv);
endsnippet

snippet pofunction "program_option parse function" bm
po::variables_map program_options(const int &argc, char** const & argv)
{
	${1:pobasic}
	${2:poOpenConfig}
    return vm;
}
endsnippet

snippet poinit "po include and namespace" b
#include <boost/program_options.hpp>
namespace po = boost::program_options;
endsnippet

snippet pobasic "po only command line setup" bm
// Declare a group of options that will be
// allowed only on command line
po::options_description generic("Generic options");
generic.add_options()
	("version,v", "print version string")
	("help,h", "produce help message")
	("config,c", po::value<string>()->default_value("config_file.init"),
		  "name of a file of a configuration.")
	;

// Declare a group of options that will be
// allowed both on command line and in
// config file
po::options_description config("Configuration");
config.add_options()
	("${1:cmdlinename}", po::value<int>()->default_value(${2}),
		  "$1 description")
	;

// Hidden options, will be allowed both on command line and
// in config file, but will not be shown to the user.
po::options_description hidden("Hidden options");
hidden.add_options()
	("input-file", po::value< vector<string> >(), "input file")
	;

po::options_description cmdline_options;
cmdline_options.add(generic).add(config).add(hidden);

po::options_description config_file_options;
config_file_options.add(config).add(hidden);

po::options_description visible("Allowed options");
visible.add(generic).add(config);

po::positional_options_description p;
p.add("input-file", -1);

po::variables_map vm;
store(po::command_line_parser(argc, argv).
	  options(cmdline_options).positional(p).run(), vm);
notify(vm);
if (vm.count("help")) {
	cout << visible << "\n";
	return 0;
}

endsnippet

snippet poOpenConfig "open config file" bm
string config_file = vm["config"].as<string>();
ifstream ifs(config_file.c_str());
if (!ifs)
{
	throw(runtime_error("Can not open config file: " + config_file + " ,use -c option"));
}
else
{
	store(parse_config_file(ifs, config_file_options), vm);
	notify(vm);
}
endsnippet
#####  CATCH  #######
snippet "(?i)test_case" "catch-test-case" rb
TEST_CASE("${1:Description}", "[${2:tag}]"){${0}}
endsnippet

snippet "(?i)section" "catch-test-section" rb
SECTION("${1:Description}"){
${0}
}
endsnippet

snippet "(?i)test_case_m" "catch-test-case-method" rb
TEST_CASE_METHOD(${1:FixtureClass}, "${2:Description}", "[${3:tag}]"){${0}}
endsnippet

snippet "(?i)capture" "catch-capture" rb
CAPTURE( ${0:theAnswer"} )
endsnippet

snippet "(?i)info" "catch-info" rb
INFO( "${1:someInfoString} " << ${0:a_variable"} )
endsnippet

snippet "(?i)scen" "catch-scenario" rb
SCENARIO( "${1:test name}", "[${2:tag}]" ){${0}}
endsnippet

snippet "(?i)req" "catch-require" rb
REQUIRE( ${1:condToTest} ${2:==} ${0:Known} );
endsnippet

snippet "(?i)req" "catch-check" rb
CHECK( ${1:condToTest} ${2:==} ${0:Known} );
endsnippet

snippet "(?i)given" "catch-given" rb
GIVEN( "${1:description}" ){${0}}
endsnippet

snippet "(?i)when" "catch-when" rb
WHEN( "${1:description}" ){${0}}
endsnippet

snippet "(?i)then" "catch-then" rb
THEN( "${1:description}" ){${0}}
endsnippet

snippet "(?i)andthen" "catch-andthen" rb
AND_THEN( "${1:description}" ){${0}}
endsnippet

snippet "(?i)andwhen" "catch-andwhen" rb
AND_WHEN( "${1:description}" ){${0}}
endsnippet

snippet "foru" "for unsigned" rb
for (unsigned int ${1:i} = 0; $1 < ${2:ImageDimension}; ++$1)${0}
endsnippet

snippet "fora" "for const auto &" rb
for(const auto & ${1:i} : ${2})${0}
endsnippet

snippet "foriterc" "for const iterator std=c++98" rb
for (${1:Type}::const_iterator it = ${2:vector}.begin(); it != $2.end(); ++it)${0}
endsnippet

snippet "ctr" "const type &" rs
const ${1:Type} & ${0}
endsnippet
snippet "csr" "const std::string &" rs
const std::string & ${0}
endsnippet
snippet "cvr" "const std::vector &" rs
const std::vector<${1:Type}> & ${0}
endsnippet

snippet "RO5" "rule of 5 for base class with virtual destructor" rb
$1(const $1&) = default;
$1($1&&) = default;
$1& operator=(const $1&) = default;
$1& operator=($1&&) = default;
~$1() = default
endsnippet
snippet "RO5poly" "rule of 5 for base class with virtual destructor" rb
$1(const $1&) = default;
$1($1&&) = default;
$1& operator=(const $1&) = default;
$1& operator=($1&&) = default;
virtual ~$1() = default;
endsnippet

############################################################
##################### DGTAL ################################
############################################################

global !p
def header_guard():
    return fn.replace('.', '_').upper()

def dgtal_py_class_name(str_to_remove):
    return snip.basename.replace(str_to_remove, '')

def dgtal_py_class_name_with_suffix(str_to_remove):
    return dgtal_py_class_name(str_to_remove) + '.h'

def dgtal_header_from_current_file(str_to_remove):
    from pathlib import Path; path_python = Path(path)
    dgtal_header = str(path_python.parent.joinpath(dgtal_py_class_name_with_suffix(str_to_remove))).replace('wrap', 'DGtal')
    return dgtal_header

endglobal

snippet dgtal_init_py "license plus headers in _py.cpp file" b
/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

#include "dgtal_pybind11_common.h"

#include "`!p snip.rv = dgtal_py_class_name('_py')`_types_py.h"
#include "`!p snip.rv = dgtal_py_class_name('_py')`_declare_py.h"

namespace py = pybind11;
using namespace DGtal;

void init_`!p snip.rv = snip.basename.replace('_py', '')`(py::module & m) {
    using X = `!p snip.rv = snip.basename.replace('_py', '')`;
    auto py_class_X = declare_`!p snip.rv = snip.basename.replace('_py', '')`<X>(m, "X");
}
endsnippet

snippet dgtal_init_declare "license plus headers in _declare_py.h" b
/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

#ifndef DGTAL_`!p snip.rv = header_guard()`
#define DGTAL_`!p snip.rv = header_guard()`

#include "dgtal_pybind11_common.h"

#include "`!p snip.rv = dgtal_header_from_current_file("_declare_py")`"
#include "`!p snip.rv = dgtal_py_class_name('_declare_py')`_types_py.h"

template<typename T`!p snip.rv = dgtal_py_class_name("_declare_py")`>
pybind11::class_<T`!p snip.rv = dgtal_py_class_name("_declare_py")`> declare_`!p snip.rv = dgtal_py_class_name("_declare_py")`(pybind11::module &m,
	const std::string &typestr) {
    namespace py = pybind11;
    using TT = T`!p snip.rv = dgtal_py_class_name("_declare_py")`;
    using TTPoint = typename TT::Point;

    const std::string docs = R"(Docs for this class)";
    auto py_class = py::class_<TT>(m, typestr.c_str(), docs.c_str());

    // ----------------------- Constructors -----------------------------------
    py_class.def(py::init());
    py_class.def(py::init<const TT &>());

    // ----------------------- Python operators -------------------------------
    py_class.def("__len__", &TT::size);
    py_class.def("__getitem__", [](const TT &self, const size_t index) {
        if (index >= self.size()) throw py::index_error();
        return self[index];
        });
    py_class.def("__setitem__", [](TT &self, const size_t index,
            const typename TT::Component value) {
        if (index >= self.size()) throw py::index_error();
        self[index] = value;
        });
    py_class.def("__iter__", [](const TT & self) {
        return py::make_iterator(self.begin(), self.end()); },
         py::keep_alive<0, 1>() /* Keep object alive while iterator exists */);

    // ----------------------- Class operators --------------------------------

    // Arithmetic
    py_class.def(py::self + py::self);
    py_class.def(py::self - py::self);
    py_class.def(py::self * py::self);
    py_class.def(py::self / py::self);
    py_class.def(py::self += py::self);
    py_class.def(py::self -= py::self);
    py_class.def(py::self *= py::self);
    py_class.def(py::self /= py::self);

    py_class.def(py::self + TT::TValue());
    py_class.def(py::self - TT::TValue());
    py_class.def(py::self * TT::TValue());
    py_class.def(py::self / TT::TValue());
    py_class.def(TT::TValue() + py::self);
    py_class.def(TT::TValue() - py::self);
    py_class.def(TT::TValue() * py::self);
    py_class.def(TT::TValue() / py::self);

    py_class.def(py::self *= TT::TValue());
    py_class.def(py::self /= TT::TValue());

    // Negation
    py_class.def(-py::self);

    // Comparisons
    py_class.def(py::self == py::self);
    py_class.def(py::self != py::self);

    // py_class.def(py::hash(py::self));

    // ----------------------- Class functions --------------------------------

    // ----------------------- Class data -------------------------------------
    py_class.def_property_readonly_static("TPoint",
            [](py::object /* self */) {
            return py::type::of<TTPoint>();
            });

    // ----------------------- Print / Display --------------------------------
    py_class.def("__str__", [](const TT & self) {
        std::stringstream os;
        self.selfDisplay(os);
        return os.str();
    });

    py_class.def("__repr__", [typestr](const TT & self) {
        std::stringstream os;
        os << typestr;
        os << "(";
        auto py_X = py::cast(self.myX);
        os << py_X.attr("__repr__")();
        os << ", ";
        os << ")";
        return os.str();
    });

    return py_class;
}
#endif
endsnippet

snippet dgtal_init_types "license plus headers in _types_py.h" b
/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

#ifndef DGTAL_`!p snip.rv = header_guard()`
#define DGTAL_`!p snip.rv = header_guard()`

#include "`!p snip.rv = dgtal_header_from_current_file("_types_py")`"

namespace DGtal {
    namespace Python {
        using X = DGtal::;
    } // namespace Python
} // namespace DGtal
#endif
endsnippet

snippet pydoc "docs for pybind" bm
    const std::string $1_docs =
R"(${7:One liner}

Parameters
----------
${2:arg1} : ${3:type}
    ${4:Description}

Returns
-------
${5:type}
    ${6:Description}
)";
endsnippet
############################################################
####################  END DGTAL ############################
############################################################
