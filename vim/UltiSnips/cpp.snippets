snippet liccurrent "Current license" b
/*=========================================================================
 *
 *  Copyright Insight Software Consortium
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0.txt
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *=========================================================================*/

endsnippet
global !p
import vim
def commentLine(ll = 40):
	try:
	    xrange
	except:
	    xrange=range
	r="/"
	for a in xrange(ll - 2):
		r+="*"
	r+="/"
	return r

endglobal
snippet "(\/\/(\s)?)?sep" "---- ----//" rb
`!p snip.rv = commentLine()`
endsnippet
snippet com "Comment /** */" b
/** ${1:Comment} */
endsnippet
snippet comlin "Comment line" !b
/************ ${1:TEXT} *************/
endsnippet
snippet comsep "Comment Separator, with fixed length" !b
`!p snip.rv = commentLine()`
/******* ${1:TEXT} ********/
`!p snip.rv = commentLine()`
$0
endsnippet
snippet ifndef "Expand ifdef" !b
#ifndef $1
#define $1
	$2
#endif
endsnippet

snippet testinit "Boost test init test module" b
///Flag to use BOOST_TEST dynamic library, not just the include library.
#define BOOST_TEST_DYN_LINK
/// Module subsitutes the main C++ function, only one module per project.
#define BOOST_TEST_MODULE $1_module
endsnippet

snippet testinclude "Boost test include: unit_test.hpp" b
#include <boost/test/unit_test.hpp>
endsnippet

snippet testsuite "Boost test suite" b
BOOST_AUTO_TEST_SUITE($1)
	$2
BOOST_AUTO_TEST_SUITE_END()
endsnippet

snippet testcase "Boost test case" b
BOOST_AUTO_TEST_CASE($1)
{
	$2
}
endsnippet

snippet bc "BOOST_CHECK" b
BOOST_CHECK(${1:comparisson});
endsnippet
snippet bcm "BOOST_CHECK_MESSAGE" b
BOOST_CHECK_MESSAGE(${1:comparisson},
	"${2:message}");
endsnippet
snippet bw "BOOST_WARN" b
BOOST_WARN(${1:comparisson});
endsnippet
snippet br "BOOST_REQUIRE" b
BOOST_REQUIRE(${1:comparisson});
endsnippet
snippet bceq "BOOST_CHECK_EQUAL" b
BOOST_CHECK_EQUAL($1,$2);
endsnippet
snippet bcgt "BOOST_CHECK_GT" b
BOOST_CHECK_GT($1,$2);
endsnippet
snippet bclt "BOOST_CHECK_LT" b
BOOST_CHECK_LT($1,$2);
endsnippet

snippet defvtk6 "VTK6 compatibility defines" b
#define vtkRenderingCore_AUTOINIT 4(vtkInteractionStyle,vtkRenderingFreeType, \
vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)
#define vtkRenderingVolume_AUTOINIT 1(vtkRenderingVolumeOpenGL)
endsnippet

snippet setget "set and get function in .h" b
void Set${1:CamelName}(${2:type} ${1/(^[A-Z])|([A-Z]+)/(?1:\l$0)(?2:_\l$0)/g}){ ${1/(^[A-Z])|([A-Z]+)/(?1:\l$0)(?2:_\l$0)/g}_ = ${1/(^[A-Z])|([A-Z]+)/(?1:\l$0)(?2:_\l$0)/g};};
$2 Get$1(){ return ${1/(^[A-Z])|([A-Z]+)/(?1:\l$0)(?2:_\l$0)/g}_;};
endsnippet


# Casts
snippet cast "Static Cast" w
static_cast<${1}>(${2})${0}
endsnippet
snippet cast "Reinterpret Cast" w
reinterpret_cast<${1}>(${2})${0}
endsnippet
snippet cast "Dynamic Cast" w
dynamic_cast<${1}>(${2})${0}
endsnippet
snippet cast "Const Cast" w
const_cast<${1}>(${2})${0}
endsnippet

# Google Mock
snippet ass "ASSERT_THAT Google Mock" b
ASSERT_THAT($1,$2);
endsnippet

snippet TEST_F "TEST_F Google Mock" !b
TEST_F(${1:FixtureClass}, ${2:TestName}) {
	$3
}
endsnippet
snippet TESTG "TEST Google Mock" !b
TEST(${1:TestClass}, ${2:TestName}) {
	$3
}
endsnippet
#boost: program_options
snippet vflag "VFLAG conditional to visualize tests" b
if (VFLAG) viewer.Visualize();
endsnippet

snippet poclass "program_option full class .cpp" bm
#include <iostream>
#include <string>
#include <fstream>
using namespace std;
${1:poinit}
${2:pofunction}
endsnippet

snippet pocall "call to program options from main()" b
auto vm = program_options(argc, argv);
endsnippet

snippet pofunction "program_option parse function" bm
po::variables_map program_options(const int &argc, char** const & argv)
{
	${1:pobasic}
	${2:poOpenConfig}
    return vm;
}
endsnippet

snippet poinit "po include and namespace" b
#include <boost/program_options.hpp>
namespace po = boost::program_options;
endsnippet

snippet pobasic "po only command line setup" bm
// Declare a group of options that will be
// allowed only on command line
po::options_description generic("Generic options");
generic.add_options()
	("version,v", "print version string")
	("help,h", "produce help message")
	("config,c", po::value<string>()->default_value("config_file.init"),
		  "name of a file of a configuration.")
	;

// Declare a group of options that will be
// allowed both on command line and in
// config file
po::options_description config("Configuration");
config.add_options()
	("${1:cmdlinename}", po::value<int>()->default_value(${2}),
		  "$1 description")
	;

// Hidden options, will be allowed both on command line and
// in config file, but will not be shown to the user.
po::options_description hidden("Hidden options");
hidden.add_options()
	("input-file", po::value< vector<string> >(), "input file")
	;

po::options_description cmdline_options;
cmdline_options.add(generic).add(config).add(hidden);

po::options_description config_file_options;
config_file_options.add(config).add(hidden);

po::options_description visible("Allowed options");
visible.add(generic).add(config);

po::positional_options_description p;
p.add("input-file", -1);

po::variables_map vm;
store(po::command_line_parser(argc, argv).
	  options(cmdline_options).positional(p).run(), vm);
notify(vm);
if (vm.count("help")) {
	cout << visible << "\n";
	return 0;
}

endsnippet

snippet poOpenConfig "open config file" bm
string config_file = vm["config"].as<string>();
ifstream ifs(config_file.c_str());
if (!ifs)
{
	throw(runtime_error("Can not open config file: " + config_file + " ,use -c option"));
}
else
{
	store(parse_config_file(ifs, config_file_options), vm);
	notify(vm);
}
endsnippet
#####  CATCH  #######
snippet "(?i)test_case" "catch-test-case" rb
TEST_CASE("${1:Description}", "[${2:tag}]"){${0}}
endsnippet

snippet "(?i)section" "catch-test-section" rb
SECTION("${1:Description}"){
${0}
}
endsnippet

snippet "(?i)test_case_m" "catch-test-case-method" rb
TEST_CASE_METHOD(${1:FixtureClass}, "${2:Description}", "[${3:tag}]"){${0}}
endsnippet

snippet "(?i)capture" "catch-capture" rb
CAPTURE( ${0:theAnswer"} )
endsnippet

snippet "(?i)info" "catch-info" rb
INFO( "${1:someInfoString} " << ${0:a_variable"} )
endsnippet

snippet "(?i)scen" "catch-scenario" rb
SCENARIO( "${1:test name}", "[${2:tag}]" ){${0}}
endsnippet

snippet "(?i)req" "catch-require" rb
REQUIRE( ${1:condToTest} ${2:==} ${0:Known} );
endsnippet

snippet "(?i)req" "catch-check" rb
CHECK( ${1:condToTest} ${2:==} ${0:Known} );
endsnippet

snippet "(?i)given" "catch-given" rb
GIVEN( "${1:description}" ){${0}}
endsnippet

snippet "(?i)when" "catch-when" rb
WHEN( "${1:description}" ){${0}}
endsnippet

snippet "(?i)then" "catch-then" rb
THEN( "${1:description}" ){${0}}
endsnippet

snippet "(?i)andthen" "catch-andthen" rb
AND_THEN( "${1:description}" ){${0}}
endsnippet

snippet "(?i)andwhen" "catch-andwhen" rb
AND_WHEN( "${1:description}" ){${0}}
endsnippet

snippet "foru" "for unsigned" rb
for (unsigned int ${1:i} = 0; $1<${2:ImageDimension}; ++$1)${0}
endsnippet

snippet "foriterc" "for const iterator std=c++98" rb
for (${1:Type}::const_iterator it = ${2:vector}.begin(); it != $2.end(); ++it)${0}
endsnippet
